<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bildklick-Quiz ‚Äì Spieler</title>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
</head>
<body>
  <div class="container">
    <h1 class="h">Bildklick-Quiz ‚Äì Spieler</h1>

    <div class="card">
      <div class="row">
        <div>
          <div class="small">Dein Name</div>
          <input id="nameInput" class="input" placeholder="Name‚Ä¶" />
        </div>
        <button id="saveName" class="btn">Speichern</button>
        <div style="margin-left:auto">
          <button id="muteBtn" class="btn">üîá Stumm</button>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:3">
        <div class="stage" id="stage">
          <img id="stageImg" src="/images/sample.png" />
          <div id="mask" class="mask"></div>

          <!-- Sichtfenster (Reveals) -->
          <div id="revealLayer"></div>

          <!-- Frage/Anweisung vom Moderator -->
          <div id="questionOverlay"
               style="position:absolute;left:0;right:0;top:0;padding:8px 12px;
                      background:rgba(0,0,0,.6);font-weight:600;display:none"></div>

          <!-- Zielkreis (ein/aus vom Moderator) -->
          <div id="targetRing" class="click-ring" style="display:none"></div>

          <!-- Vorschau des eigenen Klicks -->
          <div id="previewDot" class="click-dot" style="display:none"></div>
          <div id="previewRing" class="click-ring" style="display:none"></div>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small" id="hint">Warte auf Start‚Ä¶</div>
        </div>
      </div>

      <div class="card" style="flex:1">
        <h3 class="h">Audio</h3>
        <div class="small">Hintergrundmusik (global vom Moderator, lokal stumm m√∂glich)</div>
        <audio id="bgm" src="/sfx/bg.mp3" loop></audio>
        <div class="row" style="margin-top:6px">
          <button class="btn" id="playBgm">‚ñ∂Ô∏è Start</button>
          <button class="btn" id="pauseBgm">‚è∏Ô∏è Pause</button>
        </div>
      </div>
    </div>
  </div>

<script>
const socket = io({ query: { role: 'player' } });

const nameInput = document.getElementById('nameInput');
document.getElementById('saveName').onclick = () => {
  socket.emit('player:setName', nameInput.value.trim());
};

// Stage/DOM
const stage = document.getElementById('stage');
const stageImg = document.getElementById('stageImg');
const mask  = document.getElementById('mask');
const revealLayer = document.getElementById('revealLayer');
const questionOverlay = document.getElementById('questionOverlay');
const targetRing = document.getElementById('targetRing');
const previewDot  = document.getElementById('previewDot');
const previewRing = document.getElementById('previewRing');
const hint   = document.getElementById('hint');

let clickRadiusPct = 6;
let canClick = false;   // erst wenn Server freigibt
let locked = false;
let localMute = false;

// Audio
const bgm = document.getElementById('bgm');
document.getElementById('playBgm').onclick = () => { bgm.play().catch(()=>{}); };
document.getElementById('pauseBgm').onclick = () => bgm.pause();
document.getElementById('muteBtn').onclick = () => {
  localMute = !localMute;
  updateVolume();
  document.getElementById('muteBtn').textContent = localMute ? "üîà Entstummen" : "üîá Stumm";
};
let globalVolume = 0.5;
function updateVolume() { bgm.volume = localMute ? 0 : globalVolume; }
socket.on('volume:update', (v) => { globalVolume = Number(v)||0; updateVolume(); });

// Hallo/Init
socket.on('hello', (st) => {
  if (st.round && st.round.imageUrl) stageImg.src = st.round.imageUrl;
  globalVolume = st.volume ?? 0.5;
  updateVolume();
});

// ===== Hilfsfunktion: Reveal-Kreis mit Bild als Hintergrund rendern =====
function addRevealCircle({ xPct, yPct, rPct }) {
  const imgUrl = stageImg.currentSrc || stageImg.src;
  const div = document.createElement('div');
  div.className = 'reveal-window';
  // Direkt im Element stylen, damit es auch ohne ge√§ndertes CSS funktioniert:
  div.style.position = 'absolute';
  div.style.inset = '0';
  div.style.backgroundImage = `url('${imgUrl}')`;
  div.style.backgroundRepeat = 'no-repeat';
  div.style.backgroundPosition = 'center center';
  div.style.backgroundSize = 'cover';
  div.style.clipPath = `circle(${rPct}% at ${xPct}% ${yPct}%)`;
  revealLayer.appendChild(div);
}

// Runde startet
socket.on('round:started', (r) => {
  stageImg.src = r.imageUrl;
  clickRadiusPct = r.clickRadiusPct || 6;
  locked = false;
  canClick = false;               // erst nach Server-Signal
  stage.classList.remove('clickable');
  hint.textContent = "Bild sichtbar ‚Ä¶ gleich wird es schwarz.";
  revealLayer.innerHTML = '';
  previewDot.style.display = 'none';
  previewRing.style.display= 'none';
  questionOverlay.style.display = 'none';
  targetRing.style.display = 'none';
  mask.classList.add('hidden'); // sichtbar

  setTimeout(() => {
    mask.classList.remove('hidden'); // schwarz
  }, r.visibleMs || 3000);
});

// Server erlaubt Klicks (nach Dunkelphase)
socket.on('round:allowClicks', () => {
  if (locked) return;
  canClick = true;
  stage.classList.add('clickable');
  hint.textContent = "Bild verdeckt ‚Äì jetzt einmal klicken zum Festlegen!";
});

// NUR eigenen Klickradius zeigen, wenn Admin ‚ÄûKlicks zeigen‚Äú dr√ºckt
socket.on('round:revealSelf', ({ click, clickRadiusPct }) => {
  revealLayer.innerHTML = '';
  if (!click) return;
  const r = (clickRadiusPct || 6);
  addRevealCircle({ xPct: click.x * 100, yPct: click.y * 100, rPct: r });
});

// Auswertung: alle Klickbereiche f√ºr alle sichtbar
socket.on('round:judged', ({ winners, clicks, clickRadiusPct, target }) => {
  showReveals(clicks, clickRadiusPct);
  const youWin = (winners||[]).includes(socket.id);
  hint.textContent = youWin ? "‚úÖ Treffer! +5 Punkte" : "‚ùå Leider daneben.";
});

// (optional, falls Server noch ein altes round:reveal sendet ‚Äì hier ignorierbar)
// socket.on('round:reveal', ({ clicks, clickRadiusPct }) => {
//   // wird nicht genutzt, da ‚ÄûrevealSelf‚Äú pro Spieler gesendet wird
// });

socket.on('round:reset', () => {
  revealLayer.innerHTML = '';
  hint.textContent = "Warte auf Start‚Ä¶";
  canClick = false;
  locked = false;
  stage.classList.remove('clickable');
  previewDot.style.display = 'none';
  previewRing.style.display= 'none';
  questionOverlay.style.display = 'none';
  targetRing.style.display = 'none';
  mask.classList.remove('hidden'); // bleibt schwarz bis n√§chste Runde
});

// Frage/Anweisung
socket.on('round:question', ({ text }) => {
  if (text && text.length) {
    questionOverlay.style.display = 'block';
    questionOverlay.textContent = text;
  } else {
    questionOverlay.style.display = 'none';
  }
});

// Zielkreis an/aus
socket.on('round:showTarget', ({ show, target }) => {
  if (show && target) {
    targetRing.style.display = 'block';
    targetRing.style.left = (target.x*100)+'%';
    targetRing.style.top  = (target.y*100)+'%';
    targetRing.style.width = (target.rPct*2)+'%';
    targetRing.style.height= (target.rPct*2)+'%';
  } else {
    targetRing.style.display = 'none';
  }
});

// Eigener Revealkreis direkt nach Auto-Lock (Sofort-Feedback)
socket.on('player:selfReveal', ({ click, clickRadiusPct }) => {
  addRevealCircle({
    xPct: click.x * 100,
    yPct: click.y * 100,
    rPct: (clickRadiusPct || 6)
  });
});

// Hilfsfunktion: alle Klicks offenlegen (f√ºr 'judged')
function showReveals(clicks, cr) {
  revealLayer.innerHTML = '';
  const r = cr || clickRadiusPct || 6;
  for (const pid in clicks) {
    const c = clicks[pid];
    addRevealCircle({ xPct: c.x * 100, yPct: c.y * 100, rPct: r });
  }
}

// Maus-Vorschau
stage.addEventListener('mousemove', (ev) => {
  if (!canClick || locked) return;
  const rect = stage.getBoundingClientRect();
  const nx = (ev.clientX - rect.left) / rect.width;
  const ny = (ev.clientY - rect.top) / rect.height;
  const x = Math.max(0, Math.min(1, nx));
  const y = Math.max(0, Math.min(1, ny));
  previewDot.style.display = 'block';
  previewRing.style.display= 'block';
  previewDot.style.left = (x*100)+'%';
  previewDot.style.top  = (y*100)+'%';
  previewRing.style.left = (x*100)+'%';
  previewRing.style.top  = (y*100)+'%';
  previewRing.style.width = (clickRadiusPct*2)+'%';
  previewRing.style.height= (clickRadiusPct*2)+'%';
});

// Auto-Lock: ein Klick = speichern (nur erlaubt nach Freigabe)
stage.addEventListener('click', (ev) => {
  if (!canClick || locked) return;
  const rect = stage.getBoundingClientRect();
  const nx = (ev.clientX - rect.left) / rect.width;
  const ny = (ev.clientY - rect.top) / rect.height;
  const x = Math.max(0, Math.min(1, nx));
  const y = Math.max(0, Math.min(1, ny));
  socket.emit('player:lock', { x, y }, (res) => {
    if (res && res.ok) {
      locked = true;
      canClick = false;
      stage.classList.remove('clickable');
      // Eigener Revealkreis kommt per 'player:selfReveal'
    } else if (res && res.msg === 'Noch nicht freigegeben') {
      canClick = false;
      stage.classList.remove('clickable');
      hint.textContent = "Noch nicht freigegeben‚Ä¶";
    }
  });
});
</script>
</body>
</html>
