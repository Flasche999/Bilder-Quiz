<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Bildklick-Quiz – Spieler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <style>
    /* Falls nicht schon in style.css enthalten: */
    .stage { position: relative; overflow: hidden; }
    #overlay, #clicks, #mask { position: absolute; inset: 0; }
    .overlay-dark { background:#000; opacity:0; transition:.2s; }
    .overlay-dark.active { opacity:1; }
    .dot  { width:10px; height:10px; border-radius:50%; transform:translate(-50%,-50%); position:absolute; }
    .ring { border:2px dashed rgba(255,255,255,.85); border-radius:50%; transform:translate(-50%,-50%); position:absolute; }
    .join { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px }
    .join .input { max-width:220px }
    .color-badge{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
  </style>
</head>
<body>
  <h1>Spieler</h1>

  <!-- Join-Gate -->
  <div class="card" id="joinCard">
    <div class="join">
      <input id="nameInput" class="input" placeholder="Dein Name">
      <input id="codeInput" class="input" placeholder="Raumcode z. B. 1234">
      <button id="joinBtn" class="btn ok">Beitreten</button>
    </div>
    <div class="small" id="joinMsg"></div>
  </div>

  <!-- Scoreboard (sichtbar für Spieler) -->
  <div class="card">
    <h3 class="h">Spieler & Punkte</h3>
    <table>
      <thead><tr><th>Name</th><th>Punkte</th><th>Farbe</th></tr></thead>
      <tbody id="scoreBody"></tbody>
    </table>
  </div>

  <div class="stage" id="stage">
    <img id="img" alt="Bild" />
    <div id="overlay" class="overlay-dark"></div>
    <div id="clicks"></div>
    <canvas id="mask"></canvas>
  </div>

  <div id="question" class="h"></div>

  <script>
    const s = io();
    let myId, myColor, curRound, myClick, joined = false;

    const img = document.getElementById('img');
    const overlay = document.getElementById('overlay');
    const clicks = document.getElementById('clicks');
    const mask = document.getElementById('mask');
    const ctx = mask.getContext('2d');
    const stage = document.getElementById('stage');
    const q = document.getElementById('question');

    const joinCard = document.getElementById('joinCard');
    const joinMsg  = document.getElementById('joinMsg');
    const nameInput= document.getElementById('nameInput');
    const codeInput= document.getElementById('codeInput');
    const joinBtn  = document.getElementById('joinBtn');

    const scoreBody = document.getElementById('scoreBody');

    // ---- Helper: sichtbare Bildfläche relativ zur Stage (ohne Letterbox-Ränder)
    function getImageContentRect(imgEl, stageEl) {
      const stageRect = stageEl.getBoundingClientRect();
      const imgRect   = imgEl.getBoundingClientRect();
      const left   = imgRect.left - stageRect.left;
      const top    = imgRect.top  - stageRect.top;
      const width  = imgRect.width;
      const height = imgRect.height;
      return { left, top, width, height }; // px relativ zur Stage
    }

    // Canvas korrekt dimensionieren
    function resize(){
      mask.width  = stage.clientWidth;
      mask.height = stage.clientHeight;
    }
    addEventListener('resize', resize);
    img.onload = () => { resize(); }; // nach Bildwechsel neu anpassen
    // initial
    requestAnimationFrame(resize);

    function drawMine(){
      clicks.innerHTML = '';
      if (!myClick) return;

      // in px relativ zur Bildfläche positionieren
      const rect = getImageContentRect(img, stage);

      const d = document.createElement('div');
      d.className = 'dot';
      d.style.left = (rect.left + myClick.x * rect.width) + 'px';
      d.style.top  = (rect.top  + myClick.y * rect.height) + 'px';
      d.style.background = myColor;
      clicks.appendChild(d);
    }

    // Spieler darf erst nach Dunkelphase klicken, genau einmal
    stage.onclick = (e) => {
      if (!joined) return;               // erst nach Join
      if (!curRound) return;
      if (Date.now() < curRound.willDarkAt) return; // erst nach Abdunkeln
      if (myClick) return;               // nur 1 Klick

      const stageRect = stage.getBoundingClientRect();
      const clickX = e.clientX - stageRect.left;
      const clickY = e.clientY - stageRect.top;

      // Nur Klicks IN der sichtbaren Bildfläche akzeptieren
      const rect = getImageContentRect(img, stage);
      if (clickX < rect.left || clickX > rect.left + rect.width ||
          clickY < rect.top  || clickY > rect.top  + rect.height) {
        return; // außerhalb geklickt → ignoriere
      }

      // Normalisieren auf 0..1 in Bildkoordinaten
      const x = (clickX - rect.left) / rect.width;
      const y = (clickY - rect.top)  / rect.height;

      myClick = { x, y };
      drawMine();
      s.emit('player:click', myClick);
    };

    function applyDark(a){ overlay.classList.toggle('active', !!a); }
    function clearMask(){ ctx.clearRect(0,0,mask.width,mask.height); }

    // Nur EIGENEN Kreis „freistanzen“ – Loch im dunklen Overlay exakt an der Bildposition
    function revealOwn(click, rPct){
      clearMask();
      if (!click) return; // kein Loch, Bild bleibt dunkel

      const rect = getImageContentRect(img, stage);
      const rPx = (rPct/100) * Math.min(rect.width, rect.height);
      const cx  = rect.left + click.x * rect.width;
      const cy  = rect.top  + click.y * rect.height;

      // gesamte Fläche schwärzen
      ctx.fillStyle = 'rgba(0,0,0,0.95)';
      ctx.fillRect(0,0,mask.width,mask.height);
      // Loch stanzen
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(cx, cy, rPx, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }

    // Server-Begrüßung (bei neuer Verbindung)
    s.on('hello', d => {
      // erwartet { needJoin:true } – UI bleibt sichtbar
    });

    // Join drücken
    joinBtn.onclick = ()=>{
      const name = nameInput.value.trim();
      const code = codeInput.value.trim();
      s.emit('player:join', { name, roomCode: code }, (res)=>{
        if(!res?.ok){
          joinMsg.textContent = res?.error === 'wrong_code'
            ? 'Falscher Raumcode.'
            : 'Bitte Name & Code prüfen.';
          return;
        }
        joinMsg.textContent = '';
        joined = true;
      });
    };

    // Erfolgreich gejoint → Farbe & evtl. laufende Runde erhalten
    s.on('joined', ({ id, color, round })=>{
      myId = id;
      myColor = color;
      joinCard.style.display = 'none';
      if (round) onStart(round);
    });

    // Scoreboard-Liste erhalten
    s.on('players:list', (list)=>{
      scoreBody.innerHTML = '';
      list.sort((a,b)=> b.score - a.score); // optional: nach Punkten sortiert
      list.forEach(p=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${p.name}</td><td>${p.score}</td><td><span class="color-badge" style="background:${p.color}"></span>${p.color}</td>`;
        scoreBody.appendChild(tr);
      });
    });

    // Rundenstart
    function onStart(r){
      curRound = r;
      myClick = null;
      drawMine();
      img.src = r.imageUrl || '';
      applyDark(false);
      clearMask();
      resize();

      // Auto-Abdunkeln nach Sichtbarkeitszeit
      const ms = Math.max(0, r.willDarkAt - Date.now());
      setTimeout(()=>{
        applyDark(true);
        q.textContent = r.question || '';
      }, ms);
    }

    s.on('round:start', onStart);

    // ★ Reveal NUR für den eigenen Klick (vom Server pro Socket gesendet)
    s.on('round:revealYou', ({ click, clickRadiusPct }) => {
      clicks.innerHTML = '';

      if (click) {
        const rect = getImageContentRect(img, stage);
        const cxPx = rect.left + click.x * rect.width;
        const cyPx = rect.top  + click.y * rect.height;
        const rPx  = (clickRadiusPct/100) * Math.min(rect.width, rect.height);

        // Dot
        const d = document.createElement('div');
        d.className = 'dot';
        d.style.left = cxPx + 'px';
        d.style.top  = cyPx + 'px';
        d.style.background = myColor;
        clicks.appendChild(d);

        // Ring
        const r = document.createElement('div');
        r.className = 'ring';
        r.style.left  = cxPx + 'px';
        r.style.top   = cyPx + 'px';
        r.style.width  = (rPx*2) + 'px';
        r.style.height = (rPx*2) + 'px';
        r.style.borderColor = myColor;
        clicks.appendChild(r);
      }

      // Runder Bildausschnitt NUR um den eigenen Klick
      resize();
      revealOwn(click, clickRadiusPct);
    });

    // Auswertung
    s.on('round:judged', ({ winners }) => {
      if (Array.isArray(winners) && winners.includes(myId)) {
        q.textContent = (q.textContent || '') + (q.textContent ? ' ' : '') + '✅ +5 Punkte!';
      }
    });
  </script>
</body>
</html>
