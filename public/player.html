<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bildklick-Quiz ‚Äì Spieler</title>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
</head>
<body>
  <div class="container">
    <h1 class="h">Bildklick-Quiz ‚Äì Spieler</h1>

    <div class="card">
      <div class="row">
        <div>
          <div class="small">Dein Name</div>
          <input id="nameInput" class="input" placeholder="Name‚Ä¶" />
        </div>
        <button id="saveName" class="btn">Speichern</button>
        <div style="margin-left:auto">
          <button id="muteBtn" class="btn">üîá Stumm</button>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card" style="flex:3">
        <div class="stage" id="stage">
          <img id="stageImg" src="/images/sample.png" />
          <div id="mask" class="mask"></div>
          <div id="revealLayer"></div>
          <div id="previewDot" class="click-dot" style="display:none"></div>
          <div id="previewRing" class="click-ring" style="display:none"></div>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small" id="hint">Warte auf Start‚Ä¶</div>
          <div style="margin-left:auto">
            <button id="lockBtn" class="btn ok" disabled>‚úÖ Eingabe</button>
          </div>
        </div>
      </div>

      <div class="card" style="flex:1">
        <h3 class="h">Audio</h3>
        <div class="small">Hintergrundmusik (global vom Moderator, lokal stumm m√∂glich)</div>
        <audio id="bgm" src="/sfx/bg.mp3" loop></audio>
        <div class="row" style="margin-top:6px">
          <button class="btn" id="playBgm">‚ñ∂Ô∏è Start</button>
          <button class="btn" id="pauseBgm">‚è∏Ô∏è Pause</button>
        </div>
      </div>
    </div>
  </div>

<script>
const socket = io({ query: { role: 'player' } });

const nameInput = document.getElementById('nameInput');
document.getElementById('saveName').onclick = () => {
  socket.emit('player:setName', nameInput.value.trim());
};

// Stage
const stage = document.getElementById('stage');
const stageImg = document.getElementById('stageImg');
const mask  = document.getElementById('mask');
const revealLayer = document.getElementById('revealLayer');
const previewDot  = document.getElementById('previewDot');
const previewRing = document.getElementById('previewRing');
const lockBtn = document.getElementById('lockBtn');
const hint   = document.getElementById('hint');

let clickRadiusPct = 6;
let canClick = false;
let locked = false;
let localMute = false;

// Audio
const bgm = document.getElementById('bgm');
document.getElementById('playBgm').onclick = () => { bgm.play().catch(()=>{}); };
document.getElementById('pauseBgm').onclick = () => bgm.pause();
document.getElementById('muteBtn').onclick = () => {
  localMute = !localMute;
  updateVolume();
  document.getElementById('muteBtn').textContent = localMute ? "üîà Entstummen" : "üîá Stumm";
};

let globalVolume = 0.5;
function updateVolume() {
  bgm.volume = localMute ? 0 : globalVolume;
}

socket.on('volume:update', (v) => {
  globalVolume = Number(v)||0;
  updateVolume();
});

socket.on('hello', (st) => {
  if (st.round && st.round.imageUrl) stageImg.src = st.round.imageUrl;
  globalVolume = st.volume ?? 0.5;
  updateVolume();
});

// Round flow
socket.on('round:started', (r) => {
  stageImg.src = r.imageUrl;
  clickRadiusPct = r.clickRadiusPct || 6;
  locked = false;
  canClick = true;
  lockBtn.disabled = false;
  hint.textContent = "Bild sichtbar ‚Äì w√§hle deinen Punkt und dr√ºcke 'Eingabe'!";
  revealLayer.innerHTML = '';
  previewDot.style.display = 'none';
  previewRing.style.display= 'none';
  mask.classList.add('hidden'); // sichtbar

  // nach sichtbarer Zeit -> Maske dr√ºber
  setTimeout(() => {
    mask.classList.remove('hidden'); // schwarz
    hint.textContent = "Bild verdeckt. Du kannst noch klicken, falls noch nicht gelockt.";
  }, r.visibleMs || 3000);
});

socket.on('round:reveal', ({ clicks, clickRadiusPct }) => {
  showReveals(clicks, clickRadiusPct);
});

socket.on('round:judged', ({ winners, clicks, clickRadiusPct, target }) => {
  showReveals(clicks, clickRadiusPct);
  // optional Hinweis
  const youWin = (winners||[]).includes(socket.id);
  hint.textContent = youWin ? "‚úÖ Treffer! +5 Punkte" : "‚ùå Leider daneben.";
});

socket.on('round:reset', () => {
  revealLayer.innerHTML = '';
  hint.textContent = "Warte auf Start‚Ä¶";
  lockBtn.disabled = true;
  canClick = false;
  locked = false;
  previewDot.style.display = 'none';
  previewRing.style.display= 'none';
  mask.classList.remove('hidden'); // bleibt schwarz bis n√§chste Runde
});

function showReveals(clicks, cr) {
  revealLayer.innerHTML = '';
  // Rest bleibt schwarz, wir schneiden nur Kreise aus
  for (const pid in clicks) {
    const c = clicks[pid];
    const x = c.x*100;
    const y = c.y*100;
    const r = (cr || clickRadiusPct);
    const div = document.createElement('div');
    div.className = 'reveal-window';
    div.style.clipPath = `circle(${r}% at ${x}% ${y}%)`;
    revealLayer.appendChild(div);
  }
}

// Maus-Interaktion
stage.addEventListener('mousemove', (ev) => {
  if (!canClick || locked) return;
  const rect = stage.getBoundingClientRect();
  const nx = (ev.clientX - rect.left) / rect.width;
  const ny = (ev.clientY - rect.top) / rect.height;
  const x = Math.max(0, Math.min(1, nx));
  const y = Math.max(0, Math.min(1, ny));
  previewDot.style.display = 'block';
  previewRing.style.display= 'block';
  previewDot.style.left = (x*100)+'%';
  previewDot.style.top  = (y*100)+'%';
  previewRing.style.left = (x*100)+'%';
  previewRing.style.top  = (y*100)+'%';
  previewRing.style.width = (clickRadiusPct*2)+'%';
  previewRing.style.height= (clickRadiusPct*2)+'%';
});

stage.addEventListener('click', (ev) => {
  if (!canClick || locked) return;
  // nur Vorschau, echte Speicherung erst bei "Eingabe"
});

lockBtn.onclick = () => {
  if (!canClick || locked) return;
  // Letzte bekannte Position aus previewDot ableiten
  const rect = stage.getBoundingClientRect();
  const leftPct = parseFloat(previewDot.style.left||'50%')/100;
  const topPct  = parseFloat(previewDot.style.top ||'50%')/100;
  socket.emit('player:lock', { x:leftPct, y:topPct }, (res) => {
    if (res && res.ok) {
      locked = true;
      canClick = false;
      lockBtn.disabled = true;
      hint.textContent = "Eingabe gelockt ‚Äì warte auf Auswertung.";
    }
  });
};
</script>
</body>
</html>
